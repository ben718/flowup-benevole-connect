// filepath: c:\Users\b.mvouama\Downloads\siteweb\voisin-solidaire\src\hooks\useCategories.js
import { useEffect, useState } from 'react';
import { supabase } from '../lib/supabase';

// Cat√©gories par d√©faut √† utiliser en cas d'√©chec de chargement
const DEFAULT_CATEGORIES = [
  { id: 1, name: 'Aide aux courses', icon: 'üõí', color: 'bg-vs-blue-primary text-white', active: true },
  { id: 2, name: 'Transport', icon: 'üöó', color: 'bg-vs-green-secondary text-white', active: true },
  { id: 3, name: 'Compagnie', icon: 'üëã', color: 'bg-vs-orange-accent text-white', active: true },
  { id: 4, name: 'Bricolage', icon: 'üî®', color: 'bg-purple-500 text-white', active: true },
  { id: 5, name: 'Jardinage', icon: 'üå±', color: 'bg-green-600 text-white', active: true },
  { id: 6, name: 'Informatique', icon: 'üíª', color: 'bg-blue-600 text-white', active: true },
  { id: 7, name: 'Autre', icon: 'üìã', color: 'bg-gray-600 text-white', active: true }
];

export const useCategories = () => {
  const [categories, setCategories] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchCategories = async () => {
      try {
        setLoading(true);
        
        // V√©rifier la connexion r√©seau avant de faire l'appel
        if (!navigator.onLine) {
          throw new Error("Pas de connexion Internet. Veuillez v√©rifier votre connexion r√©seau.");
        }
        
        // V√©rifier d'abord la connexion √† Supabase
        const { checkSupabaseConnection } = await import('../lib/supabase');
        const connectionStatus = await checkSupabaseConnection('categories');
        
        if (!connectionStatus.connected) {
          throw new Error(`Impossible de se connecter √† Supabase: ${connectionStatus.error || 'Erreur inconnue'}`);
        }
        
        if (!connectionStatus.tableExists) {
          throw new Error("La table 'categories' n'existe pas dans la base de donn√©es Supabase.");
        }
        
        // Ajouter un timeout pour √©viter les attentes infinies
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error("D√©lai d'attente d√©pass√© lors du chargement des cat√©gories")), 15000);
        });
        
        // Race entre la requ√™te et le timeout
        const fetchPromise = supabase
          .from('categories')
          .select('*')
          .eq('active', true)
          .order('name');
          
        // Utilisation de Promise.race de mani√®re correcte
        let result;
        try {
          result = await Promise.race([
            fetchPromise,
            timeoutPromise
          ]);
        } catch (timeoutError) {
          throw timeoutError; // Propager l'erreur de timeout
        }
        
        const { data, error } = result;

        if (error) throw error;
        
        const loadedCategories = data || [];
        setCategories(loadedCategories);
        
        // Mettre en cache les cat√©gories charg√©es
        if (loadedCategories.length > 0) {
          try {
            localStorage.setItem('cachedCategories', JSON.stringify(loadedCategories));
          } catch (e) {
            console.error('Erreur lors de la mise en cache des cat√©gories:', e);
          }
        }
      } catch (err) {
        console.error('Erreur lors du chargement des cat√©gories:', err);
        
        // Am√©lioration du message d'erreur
        if (err.message.includes("Failed to fetch") || err.message.includes("NetworkError")) {
          setError("Impossible de se connecter au serveur. Veuillez v√©rifier votre connexion Internet.");
        } else if (err.message.includes("n'existe pas")) {
          setError("La table des cat√©gories n'existe pas encore. Utilisation des cat√©gories par d√©faut.");
          // Utiliser les cat√©gories par d√©faut si la table n'existe pas
          setCategories(DEFAULT_CATEGORIES);
          try {
            localStorage.setItem('cachedCategories', JSON.stringify(DEFAULT_CATEGORIES));
          } catch (e) {
            console.error('Erreur lors de la mise en cache des cat√©gories par d√©faut:', e);
          }
        } else {
          setError(err.message || "Une erreur s'est produite lors du chargement des cat√©gories");
        }
        
        // Utiliser des donn√©es en cache si disponibles
        const cachedCategories = localStorage.getItem('cachedCategories');
        if (cachedCategories) {
          try {
            setCategories(JSON.parse(cachedCategories));
            console.log('Utilisation des cat√©gories en cache');
          } catch (e) {
            console.error('Erreur lors de la lecture du cache:', e);
            // Utiliser les cat√©gories par d√©faut en dernier recours
            setCategories(DEFAULT_CATEGORIES);
          }
        } else {
          // Aucune donn√©e en cache, utiliser les cat√©gories par d√©faut
          setCategories(DEFAULT_CATEGORIES);
          console.log('Utilisation des cat√©gories par d√©faut');
        }
      } finally {
        setLoading(false);
      }
    };

    fetchCategories();
  }, []);

  return { categories, loading, error };
};

export default useCategories;
